// IP-Port Cache Schema
// Minimal schema for API and LLM response caching
// Actual response data stored on file system, DB holds metadata only

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// API REQUEST CACHE
// Caches responses from USPTO, PatentsView, PTAB, and other external APIs
// =============================================================================

model ApiRequestCache {
  id            Int       @id @default(autoincrement())

  // Request identification (composite unique key)
  endpoint      String    @db.VarChar(50)    // patentsview, file-wrapper, ptab
  requestType   String    @map("request_type") @db.VarChar(50)  // patent, citations, application, ipr
  requestKey    String    @map("request_key") @db.VarChar(100)  // patent_id, application_number, etc.

  // File reference (actual data on disk)
  filePath      String    @map("file_path") @db.VarChar(255)  // relative path from cache/
  fileSize      Int?      @map("file_size")   // bytes

  // Status
  statusCode    Int       @default(200) @map("status_code")
  errorMessage  String?   @map("error_message") @db.VarChar(255)

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")

  @@unique([endpoint, requestType, requestKey])
  @@index([endpoint, requestType])
  @@map("api_request_cache")
}

// =============================================================================
// LLM RESPONSE CACHE
// Caches LLM analysis results (patent analysis, sector classification, etc.)
// =============================================================================

model LlmResponseCache {
  id            Int       @id @default(autoincrement())

  // Request identification (composite unique key)
  promptType    String    @map("prompt_type") @db.VarChar(50)  // patent-analysis, sector-classification
  entityKey     String    @map("entity_key") @db.VarChar(100)  // patent_id or other identifier
  model         String    @db.VarChar(50)    // claude-sonnet-4-20250514, etc.

  // File reference (actual data on disk)
  filePath      String    @map("file_path") @db.VarChar(255)
  fileSize      Int?      @map("file_size")

  // Token tracking (useful for cost estimation)
  inputTokens   Int?      @map("input_tokens")
  outputTokens  Int?      @map("output_tokens")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")

  @@unique([promptType, entityKey, model])
  @@index([promptType])
  @@map("llm_response_cache")
}

// =============================================================================
// USER & AUTH
// =============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  passwordHash  String?   @map("password_hash")
  accessLevel   AccessLevel @default(ANALYST) @map("access_level")
  isActive      Boolean   @default(true) @map("is_active")

  createdAt     DateTime  @default(now()) @map("created_at")
  lastLoginAt   DateTime? @map("last_login_at")

  // Relations
  focusGroups   FocusGroup[]
  focusAreas    FocusArea[]

  @@map("users")
}

enum AccessLevel {
  VIEWER
  ANALYST
  MANAGER
  ADMIN
}

// =============================================================================
// FOCUS GROUPS & FOCUS AREAS
// =============================================================================

// Focus Group: Exploratory working set (mutable, draft)
model FocusGroup {
  id            String    @id @default(cuid())
  name          String
  description   String?

  // Owner
  ownerId       String    @map("owner_id")
  owner         User      @relation(fields: [ownerId], references: [id])

  // Status
  status        FocusGroupStatus @default(DRAFT)

  // Source: how this group was created
  sourceType    FocusGroupSource @default(MANUAL) @map("source_type")
  sourceFilters Json?     @map("source_filters")  // Captured filter state if from grid

  // Hierarchy (for exclusion/refinement)
  parentId      String?   @map("parent_id")
  parent        FocusGroup? @relation("FocusGroupHierarchy", fields: [parentId], references: [id])
  children      FocusGroup[] @relation("FocusGroupHierarchy")

  // Patent membership (explicit list for working groups)
  patentIds     String[]  @map("patent_ids")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  formalizedAs  FocusArea?

  @@map("focus_groups")
  @@index([ownerId])
  @@index([status])
}

enum FocusGroupStatus {
  DRAFT           // Working/exploratory
  NEEDS_REVIEW    // Sibling/runt that needs triage
  FORMALIZED      // Converted to FocusArea
  ARCHIVED        // No longer active
}

enum FocusGroupSource {
  MANUAL          // User manually selected patents
  GRID_FILTER     // Created from grid filter state
  LLM_SUGGESTION  // Suggested by LLM analysis
  SEARCH_TERM     // Created from search term extraction
}

// Focus Area: Formalized grouping with search terms and facets (stable)
model FocusArea {
  id            String    @id @default(cuid())
  name          String
  description   String?

  // Owner
  ownerId       String    @map("owner_id")
  owner         User      @relation(fields: [ownerId], references: [id])

  // Status
  status        FocusAreaStatus @default(ACTIVE)

  // Origin (optional link to source focus group)
  sourceGroupId String?   @unique @map("source_group_id")
  sourceGroup   FocusGroup? @relation(fields: [sourceGroupId], references: [id])

  // Hierarchy
  parentId      String?   @map("parent_id")
  parent        FocusArea? @relation("FocusAreaHierarchy", fields: [parentId], references: [id])
  children      FocusArea[] @relation("FocusAreaHierarchy")

  // Scope context (optional - limits where this focus area applies)
  superSector   String?   @map("super_sector")
  primarySector String?   @map("primary_sector")

  // Search scope — the categorical boundary for search term evaluation
  searchScopeType SearchScopeType @default(PORTFOLIO) @map("search_scope_type")
  searchScopeConfig Json?  @map("search_scope_config")  // { sectors?: string[], superSectors?: string[], cpcCodes?: string[] }

  // Cached stats
  patentCount   Int       @default(0) @map("patent_count")
  lastCalculatedAt DateTime? @map("last_calculated_at")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  searchTerms     SearchTerm[]
  patents         FocusAreaPatent[]
  facetDefs       FacetDefinition[]
  promptTemplates PromptTemplate[]  // Templates optionally bound to this focus area

  @@map("focus_areas")
  @@index([ownerId])
  @@index([status])
  @@index([superSector])
}

enum FocusAreaStatus {
  ACTIVE
  DRAFT
  ARCHIVED
}

enum SearchScopeType {
  PORTFOLIO        // All patents in portfolio (default)
  SECTOR           // One or more primary sectors
  SUPER_SECTOR     // One or more super-sectors
  COMPOUND         // Boolean combination of sectors/scopes
  PATENT_FAMILY    // Citation-based family
}

// Junction table: Focus Area to Patent (many-to-many)
model FocusAreaPatent {
  id            String    @id @default(cuid())

  focusAreaId   String    @map("focus_area_id")
  focusArea     FocusArea @relation(fields: [focusAreaId], references: [id], onDelete: Cascade)

  patentId      String    @map("patent_id")  // References patent_id from JSON/external

  // How this patent became a member
  membershipType MembershipType @default(SEARCH_MATCH) @map("membership_type")

  // Match details (for search-based membership)
  matchedTermIds String[] @map("matched_term_ids")
  matchScore    Float?    @map("match_score")

  // Manual override
  manualInclude Boolean?  @map("manual_include")  // true = force include, false = force exclude

  createdAt     DateTime  @default(now()) @map("created_at")

  @@unique([focusAreaId, patentId])
  @@map("focus_area_patents")
  @@index([focusAreaId])
  @@index([patentId])
}

enum MembershipType {
  SEARCH_MATCH    // Matched via search term
  MANUAL          // Manually added
  LLM_SUGGESTED   // LLM suggested inclusion
  INHERITED       // Inherited from parent focus area
}

// =============================================================================
// SEARCH TERMS
// =============================================================================

model SearchTerm {
  id            String    @id @default(cuid())

  focusAreaId   String    @map("focus_area_id")
  focusArea     FocusArea @relation(fields: [focusAreaId], references: [id], onDelete: Cascade)

  // The search expression
  termType      SearchTermType @default(KEYWORD) @map("term_type")
  expression    String         // The actual search query

  // Source tracking
  sourceType    SearchTermSource @default(MANUAL) @map("source_type")
  sourcePatentIds String[]  @map("source_patent_ids")  // Patents it was derived from

  // Hit analysis (cached)
  hitCountPortfolio Int?    @map("hit_count_portfolio")
  hitCountScope     Int?    @map("hit_count_scope")     // Hits within active search scope
  hitCountSector    Int?    @map("hit_count_sector")
  hitCountFocusArea Int?    @map("hit_count_focus_area")
  hitCountsJson     Json?   @map("hit_counts_json")  // Detailed breakdown

  // Status
  isActive      Boolean   @default(true) @map("is_active")

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@map("search_terms")
  @@index([focusAreaId])
}

enum SearchTermType {
  KEYWORD       // Simple keyword OR search
  KEYWORD_AND   // Keywords joined with AND
  PHRASE        // Exact phrase match
  PROXIMITY     // Words within N of each other
  WILDCARD      // With wildcards/stemming
  BOOLEAN       // Complex boolean expression
}

enum SearchTermSource {
  MANUAL              // User typed it
  FREQUENCY_ANALYSIS  // From keyword frequency analysis
  PHRASE_HIGHLIGHT    // From interactive text selection
  LLM_SUGGESTION      // LLM generated
}

// =============================================================================
// FACET DEFINITIONS
// =============================================================================

model FacetDefinition {
  id            String    @id @default(cuid())

  focusAreaId   String    @map("focus_area_id")
  focusArea     FocusArea @relation(fields: [focusAreaId], references: [id], onDelete: Cascade)

  // Facet metadata
  name          String
  description   String?
  facetType     FacetType @default(ATOMIC) @map("facet_type")
  dataType      FacetDataType @default(NUMERIC) @map("data_type")

  // For numeric facets
  rangeMin      Float?    @map("range_min")
  rangeMax      Float?    @map("range_max")

  // For categorical facets
  options       String[]

  // Atomic facet: LLM configuration
  llmPrompt     String?   @map("llm_prompt")
  llmContextFields String[] @map("llm_context_fields")  // title, abstract, claims
  llmModel      String?   @map("llm_model")

  // Derived facet: calculation formula
  formula       String?   // e.g., "0.4 * claim_breadth + 0.6 * market_relevance"
  inputFacetIds String[]  @map("input_facet_ids")
  normalization NormalizationType? @default(NONE)
  normalizeScope String?  @map("normalize_scope")  // focus_area, sector, portfolio

  // Execution status
  status        FacetExecutionStatus @default(PENDING)
  completedCount Int      @default(0) @map("completed_count")
  totalCount    Int       @default(0) @map("total_count")
  lastRunAt     DateTime? @map("last_run_at")
  errorMessage  String?   @map("error_message")

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  values        FacetValue[]

  @@map("facet_definitions")
  @@index([focusAreaId])
  @@index([facetType])
}

enum FacetType {
  ATOMIC        // Single value from LLM or user
  DERIVED       // Calculated from other facets
}

enum FacetDataType {
  NUMERIC       // Float value
  CATEGORICAL   // One of predefined options
  TEXT          // Free text
  BOOLEAN       // True/false
}

enum NormalizationType {
  NONE
  MINMAX        // Scale to 0-1
  ZSCORE        // Standard score
  PERCENTILE    // Percentile rank
}

enum FacetExecutionStatus {
  PENDING       // Not started
  RUNNING       // In progress
  COMPLETE      // All patents processed
  ERROR         // Failed
}

// Facet values for individual patents
model FacetValue {
  id            String    @id @default(cuid())

  facetDefId    String    @map("facet_def_id")
  facetDef      FacetDefinition @relation(fields: [facetDefId], references: [id], onDelete: Cascade)

  patentId      String    @map("patent_id")  // References patent_id

  // The value (one of these will be populated based on dataType)
  numericValue  Float?    @map("numeric_value")
  textValue     String?   @map("text_value")
  booleanValue  Boolean?  @map("boolean_value")

  // Confidence/source tracking
  confidence    Float?    // 0-1 confidence score
  source        String?   // llm, user, calculated

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@unique([facetDefId, patentId])
  @@map("facet_values")
  @@index([facetDefId])
  @@index([patentId])
}

// =============================================================================
// PROMPT TEMPLATES
// Generic LLM prompt templates — reusable across object types
// =============================================================================

model PromptTemplate {
  id            String    @id @default(cuid())

  // Template identity
  name          String
  description   String?
  templateType  PromptTemplateType @default(FREE_FORM) @map("template_type")
  objectType    String    @default("patent") @map("object_type")  // "patent", "focus_area", "product", etc.

  // Free-form mode: raw prompt text with placeholders
  promptText    String?   @map("prompt_text")

  // Structured mode: array of question definitions
  // Each: { fieldName, question, answerType, constraints?, description? }
  questions     Json?     // StructuredQuestion[]

  // Execution config
  executionMode PromptExecutionMode @default(PER_PATENT) @map("execution_mode")
  contextFields String[]  @map("context_fields")
  llmModel      String    @default("claude-sonnet-4-20250514") @map("llm_model")

  // Placeholder delimiters (default: << and >> to avoid JSON/code conflicts)
  delimiterStart String   @default("<<") @map("delimiter_start")
  delimiterEnd   String   @default(">>") @map("delimiter_end")

  // Optional focus area binding (for contextual use)
  focusAreaId   String?   @map("focus_area_id")
  focusArea     FocusArea? @relation(fields: [focusAreaId], references: [id], onDelete: SetNull)

  // Execution status (per most recent run)
  status        PromptTemplateStatus @default(DRAFT)
  completedCount Int      @default(0) @map("completed_count")
  totalCount    Int       @default(0) @map("total_count")
  lastRunAt     DateTime? @map("last_run_at")
  errorMessage  String?   @map("error_message")

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  jobs          LlmJob[]

  @@map("prompt_templates")
  @@index([focusAreaId])
  @@index([objectType])
}

enum PromptTemplateType {
  FREE_FORM     // User writes full prompt, gets text/JSON response
  STRUCTURED    // System assembles prompt from typed questions
}

enum PromptExecutionMode {
  PER_PATENT    // Run once per patent with <<patent.*>> substitution
  COLLECTIVE    // Run once with all patent IDs/data aggregated
}

enum PromptTemplateStatus {
  DRAFT
  RUNNING
  COMPLETE
  ERROR
}

// =============================================================================
// SECTOR & SUPER-SECTOR (DB entities — replaces config-only approach)
// =============================================================================

model SuperSector {
  id            String   @id @default(cuid())

  name          String   @unique                // e.g., "SECURITY"
  displayName   String   @map("display_name")   // e.g., "Security"
  description   String?

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  sectors       Sector[]

  @@map("super_sectors")
}

model Sector {
  id              String   @id @default(cuid())

  name            String   @unique                // e.g., "video-codec"
  displayName     String   @map("display_name")   // e.g., "Video Codec"
  description     String?

  superSectorId   String?  @map("super_sector_id")
  superSector     SuperSector? @relation(fields: [superSectorId], references: [id])

  // CPC mapping (from sectorMappings config)
  cpcPrefixes     String[] @map("cpc_prefixes")

  // Metadata
  damagesTier     String?  @map("damages_tier")   // "Very High", "High", "Medium", "Low"
  patentCount     Int      @default(0) @map("patent_count")  // Cached count

  // Sector management — targets for refactoring
  targetMinSize   Int?     @map("target_min_size")
  targetMaxSize   Int?     @map("target_max_size")   // Default guidance: 500

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("sectors")
  @@index([superSectorId])
}

// =============================================================================
// LLM WORKFLOW ENGINE
// Generalized dependency framework for multi-stage LLM jobs.
// Supports tournament, two-stage, chained extraction, and custom patterns.
// =============================================================================

model LlmWorkflow {
  id              String   @id @default(cuid())

  name            String
  description     String?

  // Pattern type — workflow factories create these
  workflowType    String   @default("custom") @map("workflow_type")
                           // "tournament", "two_stage", "chained", "custom"

  // Scope — polymorphic: what entity collection this operates on
  scopeType       String   @map("scope_type")     // "focus_area", "sector", "super_sector", "portfolio"
  scopeId         String?  @map("scope_id")       // Entity ID (null for portfolio-wide)

  // Workflow-specific configuration (cluster size, strategy, topN, etc.)
  config          Json?

  // Execution state
  status          WorkflowStatus @default(PENDING)

  // Results
  finalResult     Json?    @map("final_result")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  jobs            LlmJob[]

  @@map("llm_workflows")
  @@index([scopeType, scopeId])
  @@index([status])
}

model LlmJob {
  id              String   @id @default(cuid())

  // Workflow membership (null for standalone jobs)
  workflowId      String?  @map("workflow_id")
  workflow        LlmWorkflow? @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  // What template to run
  templateId      String   @map("template_id")
  template        PromptTemplate @relation(fields: [templateId], references: [id])

  // What to run it against
  targetType      String   @map("target_type")     // "patent", "patent_group", "summary_group"
  targetIds       String[] @map("target_ids")      // Patent IDs or upstream job IDs
  targetData      Json?    @map("target_data")     // Pre-computed or upstream-injected input data

  // Execution state
  status          WorkflowStatus @default(PENDING)
  priority        Int      @default(0)
  retryCount      Int      @default(0) @map("retry_count")
  maxRetries      Int      @default(3) @map("max_retries")

  // Tournament/multi-round metadata
  roundNumber     Int?     @map("round_number")
  clusterIndex    Int?     @map("cluster_index")
  sortScore       Float?   @map("sort_score")      // Tournament-relevant score for ordering in this round

  // Results
  result          Json?
  tokensUsed      Int?     @map("tokens_used")
  errorMessage    String?  @map("error_message")

  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  createdAt       DateTime @default(now()) @map("created_at")

  // Dependencies
  dependsOn       LlmJobDependency[] @relation("downstream")
  dependedBy      LlmJobDependency[] @relation("upstream")

  @@map("llm_jobs")
  @@index([workflowId])
  @@index([status])
  @@index([templateId])
}

model LlmJobDependency {
  id              String   @id @default(cuid())

  // Upstream job must complete before downstream can start
  upstreamJobId   String   @map("upstream_job_id")
  upstreamJob     LlmJob   @relation("upstream", fields: [upstreamJobId], references: [id], onDelete: Cascade)

  downstreamJobId String   @map("downstream_job_id")
  downstreamJob   LlmJob   @relation("downstream", fields: [downstreamJobId], references: [id], onDelete: Cascade)

  // How to map upstream output → downstream input
  outputField     String?  @map("output_field")    // Which field from upstream result
  inputField      String?  @map("input_field")     // Which template parameter to populate

  @@unique([upstreamJobId, downstreamJobId])
  @@map("llm_job_dependencies")
  @@index([upstreamJobId])
  @@index([downstreamJobId])
}

enum WorkflowStatus {
  PENDING
  RUNNING
  COMPLETE
  ERROR
  CANCELLED
}

// =============================================================================
// ENTITY ANALYSIS RESULTS
// Generalized storage for LLM analysis results against any entity type.
// Replaces file-based cache/focus-area-prompts/ storage.
// =============================================================================

model EntityAnalysisResult {
  id              String   @id @default(cuid())

  // Polymorphic entity reference
  entityType      String   @map("entity_type")     // "focus_area", "sector", "super_sector",
                                                     // "competitor", "affiliate"
  entityId        String   @map("entity_id")

  // What produced this result
  templateId      String?  @map("template_id")
  jobId           String?  @map("job_id")

  // What object within the entity this result is for (null for collective/summary)
  objectType      String?  @map("object_type")      // "patent", null for collective
  objectId        String?  @map("object_id")        // Patent ID, null for collective

  // Result data
  result          Json                              // The LLM response
  resultType      String   @map("result_type")      // "structured", "free_form", "tournament_summary"
  fieldValues     Json?    @map("field_values")     // Extracted typed fields for queries

  // Metadata
  model           String?
  tokensUsed      Int?     @map("tokens_used")
  promptSent      String?  @map("prompt_sent") @db.Text

  executedAt      DateTime @map("executed_at")
  createdAt       DateTime @default(now()) @map("created_at")

  @@map("entity_analysis_results")
  @@index([entityType, entityId])
  @@index([entityType, entityId, objectId])
  @@index([templateId])
  @@index([jobId])
}

// =============================================================================
// PATENT FAMILY EXPLORATION
// On-demand family exploration from a seed patent.
// Not bulk-imported; user-initiated with depth/breadth/filter parameters.
// =============================================================================

model PatentFamilyExploration {
  id                  String   @id @default(cuid())

  // Seed patent
  seedPatentId        String   @map("seed_patent_id")

  name                String?                        // User-provided or auto-generated
  description         String?

  // Exploration parameters — depth/breadth
  maxAncestorDepth    Int      @default(2) @map("max_ancestor_depth")
  maxDescendantDepth  Int      @default(2) @map("max_descendant_depth")
  includeSiblings     Boolean  @default(true) @map("include_siblings")
  includeCousins      Boolean  @default(false) @map("include_cousins")

  // Limiting filters — constrain which patents are included
  limitToSectors      String[] @map("limit_to_sectors")
  limitToCpcPrefixes  String[] @map("limit_to_cpc_prefixes")
  limitToFocusAreas   String[] @map("limit_to_focus_areas")
  requireInPortfolio  Boolean  @default(false) @map("require_in_portfolio")

  // Execution state
  status              WorkflowStatus @default(PENDING)
  discoveredCount     Int      @default(0) @map("discovered_count")
  errorMessage        String?  @map("error_message")

  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  members             PatentFamilyMember[]

  @@map("patent_family_explorations")
  @@index([seedPatentId])
}

model PatentFamilyMember {
  id              String   @id @default(cuid())

  explorationId   String   @map("exploration_id")
  exploration     PatentFamilyExploration @relation(fields: [explorationId], references: [id], onDelete: Cascade)

  patentId        String   @map("patent_id")

  // Relationship to seed
  relationToSeed  String   @map("relation_to_seed")  // "seed", "parent", "grandparent",
                                                       // "child", "grandchild", "sibling", "cousin"
  generationDepth Int      @map("generation_depth")   // 0=seed, 1=parent/child, 2=grandparent, etc.
  inPortfolio     Boolean  @default(false) @map("in_portfolio")

  createdAt       DateTime @default(now()) @map("created_at")

  @@unique([explorationId, patentId])
  @@map("patent_family_members")
  @@index([explorationId])
  @@index([patentId])
}
